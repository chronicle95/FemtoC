=================================
= Assembly/architecture summary =
=================================

 Compiler target is an abstract stack machine on a flat
 memory cell set.

 This architecture assumes WORD cell size as a single
 datatype.
 Anything can represent a word depending on the runtime.
 This compiler produces assembly listing which is
 supposed to be datatype-independent (unless the type
 can fit minimum viable storage addressing for the
 program).

# Stack memory model:

 +------+
 | ArgN |
   ....
 | Arg2 |
 +------+
 | Arg1 | <= function arguments
 +------+
 | Ret  | <= stack frame (holds return address)
 +------+
 | Loc1 | <= local variables
 +------+
 | Loc2 |
   ....
 | LocN |
 +------+

# Instruction set:

 pushsf    - put stack frame absolute address onto head
             this address points to return address on stack 
 push <n>  - put constant on stack
 pushl <l> - put label address on stack
 pushi     - pop stack head as address
             and push value at this address
 popi      - pop (stack-0) as value
             pop (stack-1) as address
             write value to cell at address
 not       - logically invert stack head
 inv       - bitwise inversion of stack head
 add       - pop two topmost stack values
             and push their sum
 sub       - same as addition, but subtraction
 mul       - same as addition, but multiplication
 div       - same as addition, but division
 mod       - same as addtiion, but remainder of division
 ret       - return from subroutine (all the local variables get dropped,
             as the stack head points to current frame -
             where call was executed, fetches
             the return address, jumps back and
             drops the return address
 call      - call a subroutine (address is on top of stack,
             gets popped, return address is pushed)
 jump      - unconditional go to label pointed at the stack head
             head is popped, as usual
 nzjump    - conditional jump if non-zero. stack head gets popped
             twice: first time - address, second time - value
 cmpeq     - comparison operators. pop two top-most values and
 cmpne       push the result on stack
 cmplt
 cmpgt
 cmpge
 cmple
 and       - bitwise operation. two top-most stack values
             get replaced with the result
 or        - bitwise operation. two top-most stack values
             get replaced with the result
 swap      - two top-most stack values exchange their places
 dup       - duplicate stack head
 drop      - remove stack head

# Preprocessor directives:
  .word ... - a set of constant words
  .zero <n> - sequence of N zeroes

# Arrays:
 There are two types of arrays: global and local.

 Global array is nothing more than a fixed-length memory
 block. To access the global array contents, it must be
 referenced. Otherwise it gets treated as basic variable.

 Local array is represented as a pointer-on-a-stack thing.
 Its length is determined during runtime and appropriately
 sized block is allocated at need. The memory is freed
 on function return.

